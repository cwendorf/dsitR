---
title: "Advanced Example"
output:
  github_document:
    preserve_yaml: FALSE
---

```{r setup, include=TRUE}
# Load necessary functions from external file
source("http://raw.githubusercontent.com/cwendorf/dsitR/main/source-dsitR.R")
```

### Conduct the Simulation

```{r}
# Initialize agents and initial opinions
agents <- create_agents(rows=10, cols=10, opinions=3)

# Define the interactions among the agents
neighborhood1 <- create_neighborhood(agents, neighbors_moore_outside)
neighborhood2 <- create_neighborhood(agents, neighbors_random_k, params=list(k=5))
```

```{r}
# Example 1: Moore + outside neighbors
result1 <- run_simulation(agents, neighborhood1, steps=50)

# Example 2: random 5 neighbors
result2 <- run_simulation(agents, neighborhood2, steps=50)
```

### Visualize the Simulation

Plot the neighborhood at various steps (either with or without the connections among agents).

```{r}
# Custom Palette
my_palette <- colorRampPalette(c("darkgreen","white","purple"))(100)
# Opinion 1 Step 50
plot_step(
  subset(result1, time == 50),
  neighborhood = neighborhood1,
  opinion = "opinion1",
  col_palette = my_palette
)
```


```{r}
frame20 <- subset(result1, time==20)
plot_network(frame20,
  neighborhood=neighborhood1,
  opinion="opinion1",
  main="Force-directed network (t=20)"
)

animate_network(result1,
  neighborhood=neighborhood1,
  opinion="opinion1",
)
```

### Assess the Simulation

```{r}
# Assume 'frame' is the subset of the simulation at a given time
frame <- subset(result, time == 50)

# Calculate individual metrics
compute_correlation(frame)
compute_consolidation(frame)
compute_diversity(frame)
compute_clustering(frame)

#Calculate multiple metrics
metrics <- compute_metrics(frame)

metrics$correlation      # vector: correlations among opinions
metrics$consolidation    # vector: consolidation per opinion
metrics$diversity        # vector: variance per opinion
metrics$clustering       # vector: clustering per opinion
```
